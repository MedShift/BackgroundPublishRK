<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BackgroundPublish: Background Publish</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BackgroundPublish
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Background Publish </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Background publish is a Particle firmware library that makes it easy to do <code>Particle.publish</code> from a background thread. This can be helpful in assuring that your loop() stays responsive, even if you have connection problems. This is most commonly an issue with cellular devices in fringe areas and for mobile cellular devices.</p>
<p>Doing a <code>Particle.publish</code> from regular loop code can cause delays, ranging from a few seconds to at worst nearly 5 minutes. For near-real-time applications this can be unacceptable. This library assures that you can request a publish and it will not block.</p>
<p>This library does not support queuing of multiple events; that will be handled by a different library. This only handles the basic case of single-event background publish and is very light-weight.</p>
<h1>Simple Example</h1>
<p>Here's a simple example:</p>
<div class="fragment"><div class="line">#include &quot;Particle.h&quot;</div>
<div class="line"> </div>
<div class="line">#include &quot;BackgroundPublish.h&quot;</div>
<div class="line"> </div>
<div class="line">SYSTEM_MODE(SEMI_AUTOMATIC);</div>
<div class="line">SYSTEM_THREAD(ENABLED);</div>
<div class="line"> </div>
<div class="line">SerialLogHandler logHandler;</div>
<div class="line"> </div>
<div class="line">const char *eventName = &quot;publishTest&quot;;</div>
<div class="line">int counter = 0;</div>
<div class="line">const unsigned long PUBLISH_INTERVAL_MS = 30000;</div>
<div class="line">unsigned long lastPublish = 0;</div>
<div class="line"> </div>
<div class="line">void publishCallback(publish_status_t status, const char *eventName, const char *eventData, const void *context);</div>
<div class="line"> </div>
<div class="line">void setup() {</div>
<div class="line">    // This must be called from setup() to start the background publishing thread</div>
<div class="line">    BackgroundPublish::instance().start();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void loop() {</div>
<div class="line">    if (millis() - lastPublish &gt;= PUBLISH_INTERVAL_MS) {</div>
<div class="line">        lastPublish = millis();</div>
<div class="line"> </div>
<div class="line">        // This code runs every PUBLISH_INTERVAL_MS (currently 30 seconds)</div>
<div class="line"> </div>
<div class="line">        char data[64];</div>
<div class="line">        snprintf(data, sizeof(data), &quot;test %d&quot;, ++counter);</div>
<div class="line"> </div>
<div class="line">        // Use BackgroundPublish::instance().publish instead of Particle.publish</div>
<div class="line">        bool bResult = BackgroundPublish::instance().publish(eventName, data, PRIVATE | WITH_ACK, publishCallback);</div>
<div class="line">        Log.info(&quot;publish returned %d&quot;, bResult);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void publishCallback(publish_status_t status, const char *eventName, const char *eventData, const void *context) {</div>
<div class="line">    Log.info(&quot;publishCallback status=%d&quot;, status);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Basically, instead of calling:</p>
<div class="fragment"><div class="line">bool bResult = Particle.publish(eventName, data, PRIVATE | WITH_ACK);</div>
</div><!-- fragment --><p>You instead call:</p>
<div class="fragment"><div class="line">bool bResult = backgroundPublish.publish(eventName, data, PRIVATE | WITH_ACK, publishCallback);</div>
</div><!-- fragment --><p>This uses an optional asynchronous callback function to know whether the publish went out or not. This typically takes up to 20 seconds, though in some rare cases it could take up to 5 minutes.</p>
<p>There are a few cases with <code>backgroundPublish.publish()</code> returns <code>false</code> immediately:</p>
<ul>
<li>If the library has not been started or <code>name</code> is NULL, then this function returns false.</li>
<li>If there is already a publish in progress, then this function returns false.</li>
</ul>
<p>Otherwise, the function returns <code>true</code> and the optional callback will be called later with a <code>status</code> value:</p>
<ul>
<li><code>BACKGROUND_PUBLISH_STATUS_SUCCESS</code> (0)</li>
<li><code>BACKGROUND_PUBLISH_STATUS_FAILURE</code> (1)</li>
</ul>
<p>It's common to use <code>WITH_ACK</code>, which will yield a fairly reliable definition of success. If you use <code>NO_ACK</code> then success merely means an attempt was made to publish the event, not that it was actually sent successfully.</p>
<p>Failure will occur if:</p>
<ul>
<li>The cloud is not connected. This should return failure quickly with 1.4.x. It may take longer with older versions of Device OS.</li>
<li>The event cannot be sent by the timeout (about 20 seconds). </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
